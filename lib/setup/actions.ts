"use server";

import { writeFile, readFile } from "fs/promises";
import { existsSync } from "fs";
import path from "path";
import { Pool } from "pg";
import * as crypto from "node:crypto";
import { isSetupAllowed } from "./config";
import type { SetupFormData } from "./types";

interface ActionResult<T = void> {
  success: boolean;
  data?: T;
  error?: string;
}

/**
 * Test database connection
 */
export async function testDatabaseConnection(
  connectionString: string
): Promise<ActionResult<{ version: string }>> {
  if (!isSetupAllowed()) {
    return { success: false, error: "Setup is not allowed in production" };
  }

  try {
    const pool = new Pool({ connectionString });
    const result = await pool.query("SELECT version()");
    await pool.end();
    
    return {
      success: true,
      data: { version: result.rows[0].version },
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : "Connection failed";
    return { success: false, error: message };
  }
}

/**
 * Generate a secure auth secret
 */
export async function generateAuthSecret(): Promise<ActionResult<{ secret: string }>> {
  if (!isSetupAllowed()) {
    return { success: false, error: "Setup is not allowed in production" };
  }

  const secret = crypto.randomBytes(32).toString("hex");
  return { success: true, data: { secret } };
}

/**
 * Save configuration to .env.local
 */
export async function saveConfiguration(
  config: SetupFormData
): Promise<ActionResult> {
  if (!isSetupAllowed()) {
    return { success: false, error: "Setup is not allowed in production" };
  }

  try {
    const envPath = path.join(process.cwd(), ".env.local");
    
    // Read existing env if it exists
    let existingContent = "";
    if (existsSync(envPath)) {
      existingContent = await readFile(envPath, "utf-8");
    }

    // Parse existing env vars
    const existingVars: Record<string, string> = {};
    existingContent.split("\n").forEach((line) => {
      const match = line.match(/^([^#=]+)=(.*)$/);
      if (match) {
        existingVars[match[1].trim()] = match[2].trim().replace(/^"(.*)"$/, "$1");
      }
    });

    // Merge with new config
    const newVars: Record<string, string> = {
      ...existingVars,
      // Database
      DATABASE_URL: config.database.DATABASE_URL,
      DIRECT_URL: config.database.DIRECT_URL || config.database.DATABASE_URL,
      // Auth
      BETTER_AUTH_URL: config.auth.BETTER_AUTH_URL,
      BETTER_AUTH_SECRET: config.auth.BETTER_AUTH_SECRET,
      BETTER_AUTH_EMAIL: config.auth.BETTER_AUTH_EMAIL,
      // Email
      RESEND_API_KEY: config.email.RESEND_API_KEY,
      // Payments
      POLAR_ACCESS_TOKEN: config.payments.POLAR_ACCESS_TOKEN,
      POLAR_ORGANIZATION_ID: config.payments.POLAR_ORGANIZATION_ID,
      POLAR_SERVER: config.payments.POLAR_SERVER,
    };

    if (config.payments.POLAR_WEBHOOK_SECRET) {
      newVars.POLAR_WEBHOOK_SECRET = config.payments.POLAR_WEBHOOK_SECRET;
    }

    // Add social providers
    if (config.social) {
      for (const provider of config.social) {
        const upper = provider.provider.toUpperCase();
        if (provider.provider === "google") {
          newVars.NEXT_PUBLIC_GOOGLE_CLIENT_ID = provider.clientId;
          newVars.GOOGLE_CLIENT_SECRET = provider.clientSecret;
        } else {
          newVars[`${upper}_CLIENT_ID`] = provider.clientId;
          newVars[`${upper}_CLIENT_SECRET`] = provider.clientSecret;
        }
      }
    }

    // Build env content
    let envContent = `# Generated by setup wizard on ${new Date().toISOString()}\n\n`;
    
    envContent += `# Database\n`;
    envContent += `DATABASE_URL="${newVars.DATABASE_URL}"\n`;
    envContent += `DIRECT_URL="${newVars.DIRECT_URL}"\n\n`;

    envContent += `# Auth\n`;
    envContent += `BETTER_AUTH_URL="${newVars.BETTER_AUTH_URL}"\n`;
    envContent += `BETTER_AUTH_SECRET="${newVars.BETTER_AUTH_SECRET}"\n`;
    envContent += `BETTER_AUTH_EMAIL="${newVars.BETTER_AUTH_EMAIL}"\n\n`;

    envContent += `# Email\n`;
    envContent += `RESEND_API_KEY="${newVars.RESEND_API_KEY}"\n\n`;

    envContent += `# Payments\n`;
    envContent += `POLAR_ACCESS_TOKEN="${newVars.POLAR_ACCESS_TOKEN}"\n`;
    envContent += `POLAR_ORGANIZATION_ID="${newVars.POLAR_ORGANIZATION_ID}"\n`;
    envContent += `POLAR_SERVER="${newVars.POLAR_SERVER}"\n`;
    if (newVars.POLAR_WEBHOOK_SECRET) {
      envContent += `POLAR_WEBHOOK_SECRET="${newVars.POLAR_WEBHOOK_SECRET}"\n`;
    }
    envContent += `\n`;

    // Add social providers if any
    const socialKeys = Object.keys(newVars).filter(
      (k) => k.includes("CLIENT_ID") || k.includes("CLIENT_SECRET")
    );
    if (socialKeys.length > 0) {
      envContent += `# Social Providers\n`;
      for (const key of socialKeys) {
        envContent += `${key}="${newVars[key]}"\n`;
      }
    }

    await writeFile(envPath, envContent, "utf-8");

    return { success: true };
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to save configuration";
    return { success: false, error: message };
  }
}

/**
 * Run database migrations
 */
export async function runDatabaseMigrations(): Promise<ActionResult> {
  if (!isSetupAllowed()) {
    return { success: false, error: "Setup is not allowed in production" };
  }

  try {
    const { execSync } = await import("child_process");
    
    execSync("npx prisma generate", { 
      cwd: process.cwd(),
      stdio: "pipe",
    });
    
    execSync("npx prisma db push", { 
      cwd: process.cwd(),
      stdio: "pipe",
    });

    return { success: true };
  } catch (error) {
    const message = error instanceof Error ? error.message : "Migration failed";
    return { success: false, error: message };
  }
}

